#include<iostream>
#include"List.h"
using namespace std;
/*Подпрограмма, которая выполняет работу над стеком:
1) Добавление элемента в голову стека.
2) Удаление элемента из головы стека.*/
void Steck()
{
	char element;        
	List<char>*c = NULL;                     //Стек.
	int i = 5;                               //Переменная для выбора типа данных.
	
	/*Выбор работы, котора выполняется со стеком.
	 (Добавление, Удаление элемента)*/
	while (i != 0)
	{
		cout << "\nВыберете действия, которые будут выполняться для стека.";
		cout << "\n1 - Добавить новый элемент в голову стека";
		cout << "\n2 - Удалить головной элемент стека \n0 - Выход\n";
		/*Очистка лишнего ввода.
		Исправляет проблему переполнения
		ввода при работе с char.*/
		cin.ignore(1000, '\n');
		cin >> i;
		switch (i)
		{
			/*Дабавление элемента в голову стека.*/
		case 1:
		{
			cout << " Укажите элемент, который необходимо добавить.\n";
			cin >> element;
			c = PushFront(c, element);    
			OutputList(c);
			break;
		}
		/*Удаление элемента с головы стека.*/
		case 2:
		{
			c = PopFront(c);
			cout << endl; 
			OutputList(c);
			break;
		}
		/*выход*/
		case 0:
			break;
		default:
		{
			cout << "Выбранное действие отсутствует.";
			cout << "Повторите ввод.";
		}
		}
	}
}
/*Подпрограмма, которая выполняет работу над очередью:
1) Добавление элемента в хвост очереди.
2) Удаление головного элемента очереди.*/
void Queue()
{
	char element;
	List<char>*c = NULL;
	int i = 5;                               //Переменная для выбора типа данных
	
	/*Выбор работы, котора выполняется с очередью.
	(Добавление, Удаление элемента)*/
	while (i != 0)
	{
		cout << "\nВыберете действия, которые будут выполняться для стека.";
		cout << "\n1 - Добавить новый элемент в хвост очереди";
		cout << "\n2 - Удалить головной элемент очереди/ \n0 - Выход\n";
		/*Очистка лишнего ввода.
		Исправляет проблему переполнения
		ввода при работе с char.*/
		cin.ignore(1000, '\n');
		cin >> i;
		switch (i)
		{
			/*Добавление элемента в хвост очереди.*/
		case 1:
		{
			cout << " Укажите элемент, который необходимо добавить.";
			cin >> element;
			c = PushFront(c, element);
			OutputList(c);
			break;
		}
		/*Удаление головного элемента очереди.*/
		case 2:
		{
			c = Findend(c);    //Поиск головного элемента.
			c = PopBack(c);    
			c = FindHead(c);
			cout << endl;
			OutputList(c);
			break;
		}
		/*выход*/
		case 0:
			break;
		default:
		{
			cout << "Выбранное действие отсутствует.";
			cout << "Повторите ввод.";
		}
		}
	}
}

/*Подпрограмма, которая выполняет работу над двусторонней очередью.:
1) Добавление в начало очереди.
2) Добавление в конец очереди.
3) Удаление с начала очереди.
4) Удалениес конца очереди. */
void DEK()
{
	char element;
	List<char>*c = NULL;
	int i = 5;                               //Переменная для выбора типа данных
	
	 /*Выбор работы, котора выполняется с  двусторонней очередью.
	(Добавление, Удаление элемента)*/
	while (i != 0)
	{
		cout << "\nВыберете действия, которые будут выполняться для двусторонней очереди.";
		cout << "\n1 - Добавление в начало очереди.";
		cout << "\n2 - Добавление в конец очереди. ";
		cout << "\n3 - Удаление с начала очереди.";
		cout << "\n4 - Удаление с конца очереди. \n0 - Выход\n";
		/*Очистка лишнего ввода.
		Исправляет проблему переполнения
		ввода при работе с char.*/
		cin.ignore(1000, '\n');
		cin >> i;
		switch (i)

		{
			/*Добавление в начало очереди.*/
		case 1:
		{
			cout << " Укажите элемент, который необходимо добавить.";
			cin >> element;
			c = PushFront(c, element);    //Добавление элемента.
			OutputList(c);
			break;
		}
		/*Добавление в конец очереди.*/
		case 2:
		{
			cout << " Укажите элемент, который необходимо добавить.";
			cin >> element;
			c = Findend(c);           //Поиск последнего элемента очереди.
			c = PushBack(c, element);  //Добавление элемента.
			c = FindHead(c);
			OutputList(c);
			break;
		}
		/*Удаление с начала очереди.*/
		case 3:
		{
			c = PopFront(c);      //Удаление элемента.
			OutputList(c);
			break;
		}
		/*Удалениес конца очереди.*/
		case 4:
		{
			c = Findend(c);     //Поиск последнего элемента очереди.
			c = PopBack(c);      //Удаление элемента.
			c = FindHead(c);
			OutputList(c);
			break;
		}
		/*выход*/
		case 0:
			break;
		default:
		{
			cout << "Выбранное действие отсутствует.";
			cout << "Повторите ввод.";
		}
		}
	}
}

/*Выбор над чем будет производиться работа:
(Стек, очередь, двусторонняя очередь)*/
void SteckQueue()
{
	int i = 5;
	while (i != 0)
	{
		cout << "\nВыберете с чем будет производиться работа:";
		cout << "\n1 - Стек\n2 - Очередь";
		cout << "\n3 - Дек. Двусторонняя очередь.\n0 - Выход\n";
		/*Очистка лишнего ввода.
		Исправляет проблему переполнения
		ввода при работе с char.*/
		cin.ignore(1000, '\n');
		cin >> i;
		switch (i)

		{
			/*Стек.*/
		case 1:
		{
			Steck();
			break;
		}
		/*Очередь*/
		case 2:
		{
			Queue();
			break;
		}
		/*Двусторонняя очередь*/
		case 3:
		{
			DEK();
			break;
		}
		/*выход*/
		case 0:
			break;
		default:
		{
			cout << "Выбранное действие отсутствует.";
			cout << "Повторите ввод.";
		}
		}
	}
}

