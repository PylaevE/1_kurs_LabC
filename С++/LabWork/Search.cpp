#include"cstring"
#include"Search.h"
#include"List.h"

/*Подпрограмма, которая сравнивает
посимвольно две строки и возвращает
количество совпавших символов.
word - шаблон.
text - строка.
j -размер смещения шабблона в тексте.*/
int ComparingWord(char*word, char* text, int j)
{
	int s = strlen(word);
	bool coincide = true;       //Переменная для провреки совпаденя шаблона.
	int count = 0;              //Количество совпавших символовю.
								/*посимвольно проверяем
								совпадение шаблона с частью текста*/
	for (int k = s - 1; (k >= 0 && coincide == true); k--)

	{    /*Если символ не совпал выходим из цикла.*/
		if (text[k + j] != word[k])
		{
			coincide = false;
		}
		else
		{
			count++;
		}

	}
	return count;
}

/*Подпрограмма, которая по таблице суффиксов
высчитывает таблицу смещений.
suf - таблица суффиксов.
lend - длина шаблона.*/
List<int>* TableBias(List<int>* suf, int lend)
{
	/*Нахождение максимальной длины суффикса.*/
	int maxcount = FindMaxcount(suf, lend);
	List<int>* c = Findend(suf);
	List<int>* biasT = NULL;
	/*При нулевой длине суффикса , размер  смещения равен 1.*/
	biasT = PushBack(biasT, 1);
	/*Заполням таблицу смещений до
	максимальной длины суффикса*/
	for (int i = 1; i <= maxcount; i++)
	{
		int k = lend - 1;             //Индекс последнего элемента шаблона.
		int j = lend - i;             //Индекс последнего совпавшего элемента шаблона.
		while (c->key != i && c->prev != NULL)
		{
			c = c->prev;              //Переходим к предыдущему элементу списка.
			k--;
		}
		/*Добавление элемента в список.*/
		biasT = PushBack(biasT, (j - k));
		/*Перемещяем указатель в конец списка.*/
		c = Findend(suf);
	}
	/*Заполняем таблицу смещений, после
	максимальной длины суффикса.*/
	for (int y = maxcount + 1; y < lend; y++)
	{
		/*Добавление элемента в список.*/
		biasT = PushBack(biasT, lend - y);
	}
	return biasT;
}

/*Подпрограмма, которая находит в таблице
стоп символов отдаленность нужного символа.*/
int Stopind(List<stop>* c, char a)
{
	int z = -1;           //Вспомогательная переменная.
	bool i = true;        //Переменная для проверки нахождения нужного элемента.
						  /*Поиск нужного элемента в списке.*/
	while (i && c != NULL)
	{
		/*Если нашли, запоминаем отдаленность.*/
		if (c->key.key == a)
		{
			z = c->key.otdal;
			i = false;
		}
		else//Переходим к следующему элементу списка.
		{
			c = c->prev;
		}
	}
	return z;
}

/*Суффикс функция. Сравнивает суффикс шаблона со всеми элементами
шаблона и вычисляет длины суффиксов. Функция возвращает таблицу
смещений по стоп символам.
array - шаблон.
n - длина шаблона.*/
List<int>*SuffixTable(char* array, int n)
{
	List<int> *c = NULL;
	/*В суффикс таблице первый элемент всегда равен 0.*/
	c = PushFront(c, 0);
	int j = n - 1;      //Индекс последнего элеманта шаблона.
	int k = 0;          //Длина суффикса.

						/*Просматриваем строку, сравниваем элементы и заполняем
						список длинами суффиксов.*/
	for (int i = n - 2; i >= 0;)
	{
		/*Если j не является индексом последнего элемента шаблона и элементы
		не равны, то обнуляем длину суффикса и переходим в конец массива.
		*/
		if ((j < n - 1) && (array[i] != array[j]))
		{
			k = 0;
			j = n - 1;
		}
		/*Если элементы совпали, то увеличиваем
		длину суффикса.*/
		if (array[i] == array[j])
		{
			k++;
			j--;
		}
		//Добавляем в список длину суффикса.
		c = PushFront(c, k);
		i--;

	}
	List<int> *bias = NULL;
	/*Заполняем таблицу смещений по стоп символам. */
	bias = TableBias(c, n);
	return bias;
}

/*Подпрограмма, которая строит таблицу стоп символов.
array - шаблон.
n - длина шаблона.*/
List<stop>* StopTable(char*aray, int n)
{
	List<stop>* c;
	List<stop>* current = NULL;
	/*Заполняем таблицу стоп символов.*/
	for (int i = 0; i < n - 1; i++)
	{
		c = current;
		/*Проверяем встречался ли этот символ шаблона ранее*/
		while ((c != NULL) && (aray[i] != c->key.key))
		{
			c = c->prev;
		}
		/*Если символ шаблона ранее встречался,
		то меняем отдаленность. */
		if ((c != NULL) && (aray[i] == c->key.key))
		{
			c->key.otdal = n - 1 - i;
		}
		else//Добавляем элемент в список.
		{
			stop newRow;
			newRow.key = aray[i];
			newRow.otdal = n - i - 1;
			List<stop>*temp = PushBack(c, newRow);
			temp->prev = current;   // Созданный элемент списка указывает на предыдущий элемент списка.
			current = temp;
		}
	}
	return current;
}

/*Подпрограмма, которая заполняет список индексами,
когда слово встречается в тексте.
Перегруженная функция, перестроенная под алгоритм Бойера - Мура.
text - строка.
word - шаблон.
suffix  - таблица смещений по суффиксам.
st - таблица стоп символов.*/
List<int>* FindEntryTemplate(List<int>* suffix, List<stop>* st, char*text, char*word)
{
	int sizebias;                            //Расзмер смещений.
	int stopbias;                            //Размер смещеий по стоп символам.
	int n = strlen(text);                    //Длина текста.
	int s = strlen(word);                    //Длина шаблона.
	List<int> *c = NULL;                   //Выделение памяти.                            
										   /*Проходим по строке.*/
	for (int i = s - 1; i < n;)
	{
		int count = ComparingWord(word, text, i - (s-1));
		if (count == s)
		{
			/*Добавление элемента в список.*/
			i -= count;
			c = PushBack(c, i+1);
		}
		else
		{
			i -= count;
		}		
			/*Смещаемся, при этом возвращая указатель на начало шаблона.*/
			if (count > 0)
			{
				/*Изночально размер смещения равен смещению по суффиксам + количество совпавших).*/
				sizebias = count + Findind(suffix, count);
				/*Если в талбилце найден такой символ,
				то перемещаемся по его отдаленности - количество
				совпаших.*/
				if (Stopind(st, text[i]) != -1)
				{
					stopbias = Stopind(st, text[i]) - count;
				}
				else//На длину шаблона - количество совпавших.
				{
					stopbias = s - count;
				}
				/*Если смещение по стоп символам больше ,
				то меняем размер смещения.*/
				if (sizebias < stopbias)
				{
					sizebias = stopbias;
				}
				i += sizebias;
			}
			else //Перемещаемся с помощью таблицы стоп символов.
			{
				/*Если в талбилце найден такой символ,
				то перемещаемся по его отдаленности*/
				if (Stopind(st, text[i]) != -1)
				{
					i += Stopind(st, text[i]);
				}
				else//На длину шаблона.
				{
					i += s;
				}
			}
		
	}
	return c;
}

/*Префикс функция.Сравнивает префикс шаблона со всеми элементами
шаблона и вычисляет длины префиксов.
array - шаблон.*/
List<int>* PrefixTable(char* array)
{
	List<int> *c = NULL;
	/*В префикс таблице первый элемент всегда равен 0.*/
	c = PushBack(c, 0);
	int j = 0;                      //Длина префикса.
	int i = 1;
	/*Просматриваем строку, сравниваем элементы и заполняем
	список длинами префиксов.*/
	while (array[i] != '\0')
	{
		/*Если длина префикса больше нуля и элементы
		не равны обнуляем длину префикса.*/
		if ((j > 0) && (array[i] != array[j]))
		{
			j = 0;
		}
		/*Если элементы совпали, то увеличиваем
		длину префикса.*/
		if (array[i] == array[j])
		{
			j++;
		}
		//Добавляем в список длину префикса.
		c = PushBack(c, j);
		i++;
	}
	return c;
}

/*Подпрограмма, которая заполняет список индексами,
когда слово встречается в тексте.
text - строка.
word - шаблон.
prefix  - таблица префиксов.*/
List<int>* FindEntryTemplate(List<int>* prefix, char*text, char*word)

{
	int n = strlen(text);
	int s = strlen(word);
	List<int> *c = NULL;                      //Выделение памяти.                            
											  /*Проходим по строке.*/
	for (int i = 0; i < n;)
	{
		int count = 0;                       //Количество совпавших элементов.
		int j;
		for (j = 0; (text[i] == word[j]) && (j < s); j++)
		{
			count++;
			i++;
		}
		if (count == s)                     //Если нашли вхождение шаблона
		{
			/*Добавление элемента в список.*/
			c = PushBack(c, i - count);
		}
		/*Перемещаемся по строке на
		( количество совпавших - префикс последнего совпавшего.)*/
		if (count > 0)
		{
			/*Находим длину префикса в списке.*/
			i = (i - count) + (count - Findind(prefix, j - 1));

		}
		else
			i += 1; //Иначе на один шаг.
	}
	return c;
}


/*Подпрограмма, которая считает хеш
значение одного символа.*/
int HashOne(char c)
{
	return 1 << c;
}

/*Подпрограмма, которая считает хеш
значение заданной строки.*/
int Hash(char* c, int length)
{
	int sum = 0;           //Контрольная сумма.
   /*Считаем хеш-сумму.*/
	for( int i = 0; i<length; i++)
	{
		sum += HashOne(c[i]);
	}

	return sum;
}

/*Подпрограмма, поиска элементов в массиве
методом КМП (Алгоритм Кнута — Морриса — Пратта)
text - строка.
word - шаблон.*/
List<int>* KMP(char*text, char*word)
{
	List<int>* c;
	List<int>* prefix;

	/*Заполнение массива с помощью префикс функции*/
	prefix = PrefixTable(word);

	/*Заполняем список индексами начала слова,
	если оно встречатся в тексте*/
	c = FindEntryTemplate(prefix, text, word);

	/*Возвращаем указатель на первый элемент списка.*/
	c = FindHead(c);
	return c;


}

/*Подпрограмма, поиска элементов в массиве
с помощью алгоритма Бойера - Мура.
text - строка.
word - шаблон.*/
List<int>* BM(char*text, char*word)
{
	int s = strlen(word);
	List<int>* c;
	List<int>* suffix;
	List<stop>* stop;

	/*Заполнение таблицы с помощью суффикс функции*/
	suffix = SuffixTable(word, s);

	/*Заполнение таблицы стоп символов.*/
	stop = StopTable(word, s);

	/*Заполняем список индексами начала слова,
	если оно встречатся в тексте.*/
	c = FindEntryTemplate(suffix, stop, text, word);

	/*Возвращаем указатель на первый элемент списка.*/
	c = FindHead(c);
	return c;
}

/*Подпрограмма, поиска элементов в массиве
с помощью алгоритма Рабина — Карпа.
text - строка.
word - шаблон.*/
List<int>* RK(char*text, char*word)
{
	int s = strlen(word);
	int n = strlen(text);
	List<int>* c = NULL;

	char* temp = new char[s];   //Массив для шаблона из текста.
	int hashWord = Hash(word, s);     //Хеш-сумма для шаблона.
									  /*Заполняем массив длины
									  шаблона символами из текста.*/
	int i;
	for (i = 0; i < s; i++)
	{
		temp[i] = text[i];
	}
	//Считаем хеш-сумму для отрывка из текста.
	int hashTemp = Hash(temp, s);
	/*Поиск вхождений шаблона в текст.*/
	for (int j = 0; j < n; j++)
	{
		/*Сравнение хеш-сумм.*/
		if (hashWord == hashTemp)
		{
			/*Посимвольное сравнение шаблонов.*/
			if (ComparingWord(word, text, j) == s)
			{
				/*Заполнение списка.*/
				c = PushBack(c, j);
			}
		}
		/*Чтобы не пересчитывать хеш-сумму заново, изменяем её циклически:
		из начальной хеш-суммы вычитаем хеш значение певрого символа
		шаблона и прибавляем хеш значение следующего за шаблоном символа.*/
		hashTemp = hashTemp - HashOne(text[j]) + HashOne(text[s + j]);
	}
	/*Возвращаем указатель на первый элемент списка.*/
	c = FindHead(c);
	return c;
}